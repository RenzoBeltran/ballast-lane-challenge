# Generative AI Task: Task Management System

This document outlines the process of leveraging Generative AI to accelerate the development of a "Task Management System" feature, specifically focusing on the Task Table component and the underlying API.

## 1. Prompt Engineering

To ensure high-quality, idiomatic, and functioning code, the following prompt is designed to provide the AI with sufficient context, constraints, and stylistic preferences.

**Tool Used:** Cursor (Claude 3.5 Sonnet) / GitHub Copilot

**The Prompt:**

> I need to implement a **Task Management** feature for a full-stack application.
>
> **Context:**
> - **Backend:** Ruby on Rails 7, JSON API.
> - **Frontend:** React 19, TypeScript, TailwindCSS, Vite.
> - **Existing Models:** We have a `User` model with Device authentication.
>
> **Task Requirements:**
> 1.  Create a **Rails API Scaffold** for `Task` resources.
>     - Attributes: `title` (string, required), `description` (text), `status` (enum: pending, in_progress, completed), `due_date` (datetime).
>     - Associations: A Task belongs to a `User`.
>     - Controller: Standard CRUD operations (`index`, `show`, `create`, `update`, `destroy`).
>     - Authorization: Users should only manage *their own* tasks.
>
> 2.  Create a **React Table Component** (`TasksTable.tsx`) to display these tasks.
>     - Columns: Title, Status (badge), Due Date (formatted), Actions (Edit/Delete buttons).
>     - Style: Modern UI using TailwindCSS.
>     - Functionality: The component should accept an array of tasks and handle "Edit" and "Delete" clicks via props or callbacks.
>
> **Constraints & Best Practices:**
> - Use standard Rails conventions (Strong Parameters).
> - Use idiomatic React (Functional components, Typed props).
> - Ensure the Table is responsive and accessible (ARIA labels).
> - For the API, include a basic specificication (RSpec) for the `create` action to verify ownership.
>
> Please generate the Database Migration, the Rails Controller, and the React Component.

---

## 2. AI Code Generation Output

Below is a representative sample of the code generated by the AI based on the prompt above.

### A. Backend (Rails)

**Migration:**
```ruby
class CreateTasks < ActiveRecord::Migration[7.1]
  def change
    create_table :tasks do |t|
      t.string :title, null: false
      t.text :description
      t.integer :status, default: 0
      t.datetime :due_date
      t.references :user, null: false, foreign_key: true

      t.timestamps
    end
  end
end
```

**Model:**
```ruby
class Task < ApplicationRecord
  belongs_to :user
  
  enum status: { pending: 0, in_progress: 1, completed: 2 }
  
  validates :title, presence: true
end
```

**Controller:**
```ruby
class Api::V1::TasksController < ApplicationController
  before_action :authenticate_user!
  before_action :set_task, only: %i[show update destroy]

  def index
    @tasks = current_user.tasks.order(due_date: :asc)
    render json: @tasks
  end

  def create
    @task = current_user.tasks.build(task_params)
    if @task.save
      render json: @task, status: :created
    else
      render json: @task.errors, status: :unprocessable_entity
    end
  end

  # ... update and destroy methods omitted for brevity ...

  private

  def set_task
    @task = current_user.tasks.find(params[:id])
  rescue ActiveRecord::RecordNotFound
    render json: { error: "Task not found" }, status: :not_found
  end

  def task_params
    params.require(:task).permit(:title, :description, :status, :due_date)
  end
end
```

### B. Frontend (React)

**Component (`TasksTable.tsx`):**
```tsx
import React from 'react';
import { format } from 'date-fns';

type TaskStatus = 'pending' | 'in_progress' | 'completed';

interface Task {
  id: number;
  title: string;
  description: string;
  status: TaskStatus;
  due_date: string;
}

interface TasksTableProps {
  tasks: Task[];
  onEdit: (task: Task) => void;
  onDelete: (id: number) => void;
}

const statusColors: Record<TaskStatus, string> = {
  pending: 'bg-yellow-100 text-yellow-800',
  in_progress: 'bg-blue-100 text-blue-800',
  completed: 'bg-green-100 text-green-800',
};

export const TasksTable: React.FC<TasksTableProps> = ({ tasks, onEdit, onDelete }) => {
  return (
    <div className="overflow-x-auto shadow-md sm:rounded-lg">
      <table className="w-full text-sm text-left text-gray-500">
        <thead className="text-xs text-gray-700 uppercase bg-gray-50">
          <tr>
            <th className="px-6 py-3">Title</th>
            <th className="px-6 py-3">Status</th>
            <th className="px-6 py-3">Due Date</th>
            <th className="px-6 py-3">Actions</th>
          </tr>
        </thead>
        <tbody>
          {tasks.map((task) => (
            <tr key={task.id} className="bg-white border-b hover:bg-gray-50">
              <td className="px-6 py-4 font-medium text-gray-900 whitespace-nowrap">
                {task.title}
              </td>
              <td className="px-6 py-4">
                <span className={`px-2 py-1 rounded-full text-xs font-semibold ${statusColors[task.status]}`}>
                  {task.status.replace('_', ' ')}
                </span>
              </td>
              <td className="px-6 py-4">
                {task.due_date ? format(new Date(task.due_date), 'MMM d, yyyy') : '-'}
              </td>
              <td className="px-6 py-4 space-x-2">
                <button 
                  onClick={() => onEdit(task)}
                  className="font-medium text-blue-600 hover:underline"
                >
                  Edit
                </button>
                <button 
                  onClick={() => onDelete(task.id)}
                  className="font-medium text-red-600 hover:underline"
                >
                  Delete
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
```

---

## 3. Engineer's Review & Refinement

While the AI provided a solid foundation, an experienced engineer must validate, correct, and optimize the output.

### A. Validation of Suggestions
- **Database Schema:** I verified that using an `integer` for status with Rails `enum` is efficient for database storage, though I ensured the mapped values match the frontend types.
- **Security:** The AI correctly scoped queries to `current_user.tasks` instead of `Task.all`, preventing unauthorized access (IDOR vulnerabilities).

### B. Corrections & Improvements
- **Security (Corrected):** The AI's `set_task` method used `find`, which raises an exception. While it included a rescue block, I prefer checking ID existence or letting the global `ApplicationController` rescue_from handle `RecordNotFound` to keep controllers DRY.
- **Frontend Dates:** The AI used `date-fns` which is good, but I checked if it was installed. If not, I would either install it or use native `Intl.DateTimeFormat` to avoid adding a dependency for a simple table.
- **Type Safety:** I refined the `TaskStatus` type to ensure it stays in sync with the backend response. I added a `zod` schema (not shown in snippet) to validate the API response at runtime.

### C. Edge Cases & Handling
- **Empty States:** The generated code didn't handle the case where `tasks` is empty. I added a conditional render:
  ```tsx
  if (tasks.length === 0) return <div className="text-gray-500 text-center p-4">No tasks found.</div>;
  ```
- **Loading States:** I added a skeleton loader or a `isLoading` prop to the table to improve UX during data fetching.

### D. Performance & Idiomatic Quality
- **N+1 Queries:** For the basic list, the code is fine. However, if we needed to display "Assigned User" names, I would add `.includes(:user)` to the ActiveRecord query to prevent N+1 issues.
- **React Rendering:** The component is efficient. For a very large list (e.g., 1000+ tasks), I would refactor this to use virtualization (like `react-window`) or server-side pagination, which was not in the initial "simple" prompt but is a necessary consideration for production.

## 4. Final thoughts.

I'd like to response the final 4 questions mentioned in the document.


As a Senior Engineer, I treated the AI's output as a "Draft PR" requiring thorough review. Here is how I assessed and refined the code:

#### âœ… Validating the Suggestions (Security Focus)
My primary validation step was **Security Scoping**. Generative AI often defaults to insecure finders like `Task.find(params[:id])`.
* **Audit:** I verified that the generated Controller strictly implemented `current_user.tasks.find(params[:id])`.
* **Outcome:** This validation prevents **IDOR (Insecure Direct Object References)** vulnerabilities, ensuring users can never access or modify data belonging to others.

#### ðŸ›  Correcting & Improving Output (Business Logic)
The AI suggested strict validations based on the schema, but I applied **Domain-Driven design decisions**:
* **Correction:** The AI included `validates :due_date, presence: true`.
* **Refinement:** I removed this validation because, in a real-world Task Management system, tasks often start as "Backlog" items without a definitive deadline. The system needs flexibility, not rigid constraints.

#### ðŸ›¡ Handling Edge Cases & Authentication
* **Mass Assignment Protection:** I reviewed the `task_params` method to ensure `user_id` was **excluded** from the permitted parameters. This prevents a malicious actor from injecting a `user_id` in the payload to assign tasks to other users (or admins).
* **Auth Flow:** Verified that `before_action :authenticate_user!` was correctly placed at the top of the controller inheritance chain to protect all endpoints by default.

#### âš¡ Assessing Performance & Idiomatic Quality
* **Database Performance:** I checked the migration to ensure the `user_id` foreign key included a database-level **Index**. Without this, filtering tasks by user would result in full-table scans (O(n)) instead of efficient lookups.
* **Idiomatic Rails:** I assessed the use of `enum`. The AI correctly used integers for storage (efficiency) while exposing semantic query methods (e.g., `task.completed?`) instead of magic strings/numbers, adhering to Rails best practices.

AI tools are just a tool, not to trust blindly. It's important to know the subjects, theory, and to be experienced about coding, architecture, cloud, AI tools itself, prompt engineering, etc.
